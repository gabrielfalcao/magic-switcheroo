#[derive(PartialEq, Clone, Debug)]
pub enum VecsException {
    PatternNotFound(Vec<u8>),
    NotAllOccurrencesReplaced((Vec<u8>, usize, usize)),
}

pub fn rsubseq(origin: &[u8], matchsq: &[u8], replcsq: &[u8]) -> Option<Vec<u8>> {
    assert_eq!(matchsq.len(), replcsq.len());
    let mut found = Vec::<u8>::new();
    let limit = matchsq.len();
    if limit > origin.len() {
        return None
    }
    if limit == 0 {
        return Some(found);
    }
    let (fsize, _) = origin.iter().enumerate().find(|(i, _)| {
        if origin.len() < *i+limit {
            return false;
        }
        let matches = &origin[*i..*i+limit] == matchsq;
        // if matches {
        //     eprintln!("\n\x1b[1;38;5;112m<matched!>\x1b[0m");
        // }
        // eprintln!("\norigin:\x1b[1;38;5;220m{:?}\x1b[0m", origin);
        // eprintln!("pattern:\x1b[1;38;5;33m{:?}\x1b[0m", matchsq);
        // eprintln!("current:\x1b[1;38;5;160m{:?}\x1b[0m", origin[*i..*i+limit].to_vec());
        // if matches {
        //     eprintln!("\n\x1b[1;38;5;112m</matched!>\x1b[0m\n");
        // }
        matches
    })?;
    let remainder = origin[fsize+limit..].to_vec();

    found.extend(&origin[0..fsize]);
    found.extend(replcsq);
    found.extend(&remainder);
    Some(found)
}

pub fn rsubnseq(origin: &[u8], matchsq: &[u8], replcsq: &[u8], occrs: usize) -> Result<Vec<u8>, VecsException> {
    if occrs == 0 {
        return Ok(origin.to_vec());
    }
    let mut found = match rsubseq(origin, matchsq, replcsq) {
        Some(s) => s.to_vec(),
        None => return Err(VecsException::PatternNotFound(matchsq.to_vec()))
    };
    let mut srcco = 1;

    while found.len() >= matchsq.len() && occrs > srcco{
        found = match rsubseq(&found, matchsq, replcsq) {
            Some(s) => s.to_vec(),
            None => {
                break;
            }
        };
        srcco = srcco + 1;
    }
    if srcco < occrs {
        return Err(VecsException::NotAllOccurrencesReplaced((matchsq.to_vec(), srcco, occrs)))
    }
    Ok(found)
}

#[cfg(test)]
mod test_rsubnseq {
    use super::*;

    #[test]
    fn test_replace_zero_occurrences() -> Result<(), VecsException> {
        let source =      vec![0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47];
        let match_seq =   vec![0x44, 0x45, 0x46];
        let replc_seq =   vec![0x64, 0x65, 0x66];
        let expectation = vec![0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47];

        let result = rsubnseq(&source, &match_seq, &replc_seq, 0)?;

        assert_eq!((&result, result.len()), (&expectation, expectation.len()));
        Ok(())
    }

    #[test]
    fn test_replace_no_occurrences() -> Result<(), VecsException> {
        let source =      vec![0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47];
        let match_seq =   vec![0x44, 0x45, 0x46];
        let replc_seq =   vec![0x64, 0x65, 0x66];
        let expectation = vec![0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47];

        let result = rsubnseq(&source, &match_seq, &replc_seq, 0)?;

        assert_eq!((&result, result.len()), (&expectation, expectation.len()));
        Ok(())
    }

    #[test]
    fn test_replace_first_occurrence() -> Result<(), VecsException> {
        let source =      vec![0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47];
        let match_seq =   vec![0x44, 0x45, 0x46];
        let replc_seq =   vec![0x64, 0x65, 0x66];
        let expectation = vec![0x41, 0x42, 0x43, 0x64, 0x65, 0x66, 0x47];

        let result = rsubnseq(&source, &match_seq, &replc_seq, 1)?;

        assert_eq!((&result, result.len()), (&expectation, expectation.len()));
        Ok(())
    }

    #[test]
    fn test_replace_first_occurrence_complex() -> Result<(), VecsException> {
        let source      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74,
                               0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16, 0x5d, 0x00, 0x16];
        let expectation      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0xff, 0xfe, 0xfd, 0xfc,
                               0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16, 0x5d, 0x00, 0x16];
        let match_seq =   vec![0x00, 0x00, 0x00, 0x74];
        let replc_seq =   vec![0xff, 0xfe, 0xfd, 0xfc];

        let result = rsubnseq(&source, &match_seq, &replc_seq, 1)?;

        assert_eq!(result, expectation);
        Ok(())
    }

    #[test]
    fn test_replace_two_occurrences_complex() -> Result<(), VecsException> {
        let source      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74, 0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74, 0x5d, 0x00, 0x16];
        let expectation = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0xff, 0xfe, 0xfd, 0xfc, 0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16,
                               0xff, 0xfe, 0xfd, 0xfc, 0x5d, 0x00, 0x16];
        let match_seq =  vec![0x00, 0x00, 0x00, 0x74];
        let replc_seq =  vec![0xff, 0xfe, 0xfd, 0xfc];
        let result = rsubnseq(&source, &match_seq, &replc_seq, 2)?;

        assert_eq!(result, expectation);
        Ok(())
    }

    #[test]
    fn test_replace_only_first_occurrence_complex() -> Result<(), VecsException> {
        let source      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74, 0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74, 0x5d, 0x00, 0x16];
        let expectation = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0xff, 0xfe, 0xfd, 0xfc, 0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74, 0x5d, 0x00, 0x16];
        let match_seq =  vec![0x00, 0x00, 0x00, 0x74];
        let replc_seq =  vec![0xff, 0xfe, 0xfd, 0xfc];
        let result = rsubnseq(&source, &match_seq, &replc_seq, 1)?;

        assert_eq!(result, expectation);
        Ok(())
    }

}

#[cfg(test)]
mod test_rsubseq {
    use super::*;

    #[test]
    fn test_replace_first_occurrence()  {
        let source =      vec![0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47];
        let match_seq =   vec![0x44, 0x45, 0x46];
        let replc_seq =   vec![0x64, 0x65, 0x66];
        let expectation = vec![0x41, 0x42, 0x43, 0x64, 0x65, 0x66, 0x47];

        let result = rsubseq(&source, &match_seq, &replc_seq);

        assert_ne!(result, None);
        let result = result.unwrap();
        assert_eq!((&result, result.len()), (&expectation, expectation.len()));
    }

    #[test]
    fn test_replace_first_occurrence_complex()  {
        let source      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74,
                               0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16, 0x5d, 0x00, 0x16];
        let expectation      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0xff, 0xfe, 0xfd, 0xfc,
                               0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16, 0x5d, 0x00, 0x16];
        let match_seq =   vec![0x00, 0x00, 0x00, 0x74];
        let replc_seq =   vec![0xff, 0xfe, 0xfd, 0xfc];
        let result = rsubseq(&source, &match_seq, &replc_seq);

        assert_ne!(result, None);
        let result = result.unwrap();
        assert_eq!(result, expectation);
    }

    #[test]
    fn test_replace_last_occurrence_complex()  {
        let source      = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0x12, 0x04, 0x81, 0x77, 0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16,
                               0x00, 0x00, 0x00, 0x74, 0x5d, 0x00, 0x16];
        let expectation = vec![0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16,
                               0x12, 0x04, 0x81, 0x77, 0x2f, 0xe5, 0xa3, 0xe0, 0x01, 0xb5, 0x01, 0x16,
                               0xff, 0xfe, 0xfd, 0xfc, 0x5d, 0x00, 0x16];
        let match_seq =  vec![0x00, 0x00, 0x00, 0x74];
        let replc_seq =  vec![0xff, 0xfe, 0xfd, 0xfc];
        let result = rsubseq(&source, &match_seq, &replc_seq);

        assert_ne!(result, None);
        let result = result.unwrap();
        assert_eq!(result, expectation);
    }
}
